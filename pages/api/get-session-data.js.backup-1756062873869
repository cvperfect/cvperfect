// API endpoint to retrieve full CV session data for success page
import { handleCORSPreflight } from '../../lib/cors'

export default async function handler(req, res) {
  // Secure CORS handling
  const shouldContinue = handleCORSPreflight(req, res)
  if (!shouldContinue) {
    return // CORS preflight handled
  }

  if (req.method !== 'GET') {
    return res.status(405).json({ 
      success: false,
      error: 'Method not allowed. Only GET requests are accepted.' 
    })
  }

  try {
    // Set proper JSON content type first
    res.setHeader('Content-Type', 'application/json')
    
    const { session_id: rawSessionId, force_file } = req.query

    // Input sanitization
    const session_id = rawSessionId ? rawSessionId.trim() : null

    if (!session_id || session_id.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'Missing or empty session_id parameter'
      })
    }
    
    // 🎭 DEMO MODE: Handle demo session requests
    if (session_id === 'demo_session_12345') {
      console.log('🎭 DEMO MODE: Returning sample CV data')
      
      const demoData = {
        sessionId: 'demo_session_12345',
        email: 'anna.kowalska@example.com',
        plan: 'premium',
        template: 'luxury',
        cvData: 'Anna Kowalska\nanna.kowalska@example.com | +48 123 456 789 | Warszawa, Polska\n\nDOŚWIADCZENY FRONTEND DEVELOPER\n\nDoświadczony Frontend Developer z 5-letnim doświadczeniem w tworzeniu nowoczesnych aplikacji webowych. Specjalizuje się w React, TypeScript i responsive design. Pasjonat UI/UX z silnymi umiejętnościami współpracy w zespole.\n\nDOŚWIADCZENIE ZAWODOWE\n\nSenior Frontend Developer | Tech Solutions Sp. z o.o. | Warszawa | 01/2022 - obecnie\n• Liderowanie zespołu 4 programistów w tworzeniu aplikacji e-commerce\n• Implementacja responsive design i optymalizacja wydajności\n• Zwiększenie conversion rate o 25% przez optymalizację UX\n• Mentoring młodszych developerów\n\nFrontend Developer | Digital Agency | Kraków | 06/2020 - 12/2021\n• Rozwój aplikacji SPA w React dla klientów z różnych branż\n• Współpraca z zespołem UX/UI w tworzeniu przyjaznych interfejsów\n• Implementacja responsive design zgodnie z zasadami accessibility\n\nUMIEJĘTNOŚCI\n• Frontend: React, TypeScript, JavaScript (ES6+), HTML5, CSS3, SASS\n• Frameworks: Next.js, Redux, Material-UI, Styled Components\n• Tools: Git, Webpack, Jest, Figma, Adobe XD\n• Metodyki: Responsive Design, Mobile First, REST API Integration\n\nWYKSZTAŁCENIE\nMagister Informatyki | Uniwersytet Warszawski | Warszawa | 2018-2020\nSpecjalizacja: Inżynieria Oprogramowania\n\nJĘZYKI\n• Polski - ojczysty\n• Angielski - zaawansowany (C1)\n• Niemiecki - podstawowy (A2)',
        jobPosting: '',
        photo: null,
        timestamp: new Date().toISOString(),
        processed: false,
        createdAt: Date.now()
      }
      
      return res.status(200).json({
        success: true,
        source: 'demo_mode',
        cvData: demoData.cvData,
        email: demoData.email,
        plan: demoData.plan,
        jobPosting: demoData.jobPosting || '',
        photo: demoData.photo || null,
        processed: demoData.processed,
        session: {
          id: demoData.sessionId,
          customer_email: demoData.email,
          metadata: {
            plan: demoData.plan,
            template: demoData.template,
            cv: demoData.cvData,
            job: demoData.jobPosting,
            photo: demoData.photo,
            processed: demoData.processed,
            timestamp: demoData.timestamp,
            demo_mode: true
          }
        }
      })
    }
    
    // ENHANCED VALIDATION: Accept multiple session ID formats
    const isRegularSession = /^sess_[a-zA-Z0-9_]+$/.test(session_id)
    const isFallbackSession = /^fallback_[0-9]+_[a-zA-Z0-9]+$/.test(session_id)
    const isDemoSession = /^demo_session_[a-zA-Z0-9_]+$/.test(session_id)
    const isTestSession = /^test_[a-zA-Z0-9_]+$/.test(session_id)
    
    // More flexible validation
    const validSessionFormats = [
      isRegularSession,
      isFallbackSession, 
      isDemoSession,
      isTestSession
    ]
    
    if (typeof session_id !== 'string' || 
        !validSessionFormats.some(format => format) ||
        session_id.length > 100 || 
        session_id.length < 8) {
      return res.status(400).json({
        success: false,
        error: 'Invalid session_id format. Expected formats: sess_*, fallback_*, demo_session_*, or test_*',
        debug: `Received: ${session_id} (length: ${session_id.length})`
      })
    }
    
    const sessionType = isRegularSession ? 'regular' : 
                     isFallbackSession ? 'fallback' :
                     isDemoSession ? 'demo' : 
                     isTestSession ? 'test' : 'unknown'
    
    console.log('🔍 Session ID validation:', {
      sessionId: session_id,
      type: sessionType,
      length: session_id.length
    })

    const isForceFileMode = force_file === 'true'
    console.log('🔍 Retrieving session data for:', session_id, isForceFileMode ? '(FORCE FILE MODE)' : '')

    // Try to load from file system first
    const fs = require('fs').promises
    const path = require('path')
    
    try {
      const sessionsDir = path.join(process.cwd(), '.sessions')
      const sessionFile = path.join(sessionsDir, `${session_id}.json`)
      
      // Check if session file exists
      await fs.access(sessionFile)
      
      // Read session data
      const sessionData = JSON.parse(await fs.readFile(sessionFile, 'utf8'))
      
      console.log('✅ Session data loaded:', {
        sessionId: sessionData.sessionId,
        email: sessionData.email,
        plan: sessionData.plan,
        cvLength: sessionData.cvData?.length || 0,
        hasJob: !!sessionData.jobPosting,
        hasPhoto: !!sessionData.photo,
        processed: sessionData.processed
      })

      // Return full session data (ENHANCED for FAZA 3)
      return res.status(200).json({
        success: true,
        source: 'filesystem',
        cvData: sessionData.cvData, // Direct access for fallback system
        email: sessionData.email,
        plan: sessionData.plan,
        jobPosting: sessionData.jobPosting || '',
        photo: sessionData.photo || null,
        processed: sessionData.processed,
        session: {
          id: sessionData.sessionId,
          customer_email: sessionData.email,
          metadata: {
            plan: sessionData.plan,
            template: sessionData.template,
            cv: sessionData.cvData, // FULL CV DATA - no truncation
            job: sessionData.jobPosting,
            photo: sessionData.photo, // Photo data preserved
            processed: sessionData.processed,
            timestamp: sessionData.timestamp
          }
        }
      })

    } catch (fileError) {
      console.log('📝 Session file not found, trying alternative methods...')
      
      // ENHANCED FALLBACK: For fallback session IDs, skip Stripe and return guidance
      if (isFallbackSession) {
        console.log('🚑 Fallback session detected - providing recovery guidance')
        return res.status(200).json({
          success: true,
          source: 'fallback_guidance',
          fallback: true,
          guidance: {
            message: 'Session data should be available in browser storage',
            recommendation: 'Check sessionStorage and localStorage for CV data',
            fallbackSessionId: session_id
          },
          session: {
            id: session_id,
            customer_email: null,
            payment_status: 'pending_recovery',
            metadata: {
              fallback: true,
              recovery_needed: true
            }
          }
        })
      }
      
      // If force_file mode is enabled, don't try Stripe
      if (isForceFileMode) {
        console.log('🚫 Force file mode - skipping Stripe fallback')
        return res.status(404).json({
          success: false,
          source: 'filesystem',
          error: 'Session file not found (force file mode)'
        })
      }
      
      console.log('🔄 Trying Stripe fallback...')
      
      // Fallback to Stripe session lookup
      const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY)
      
      try {
        const stripeSession = await stripe.checkout.sessions.retrieve(session_id)
        
        console.log('📋 Stripe session found:', {
          id: stripeSession.id,
          email: stripeSession.customer_email,
          status: stripeSession.payment_status,
          hasMetadata: !!stripeSession.metadata
        })

        // Return Stripe data (limited)
        return res.status(200).json({
          success: true,
          session: {
            id: stripeSession.id,
            customer_email: stripeSession.customer_email,
            payment_status: stripeSession.payment_status,
            metadata: stripeSession.metadata || {}
          }
        })

      } catch (stripeError) {
        console.error('❌ Stripe session not found:', stripeError.message)
        
        return res.status(404).json({
          success: false,
          error: 'Session not found in both local storage and Stripe'
        })
      }
    }

  } catch (error) {
    console.error('❌ Get session error:', error)
    
    // Ensure we always return JSON, even on errors
    res.setHeader('Content-Type', 'application/json')
    
    // Handle specific error types
    if (error.code === 'EACCES' || error.code === 'EPERM') {
      return res.status(500).json({
        success: false,
        error: 'File system permission error'
      })
    }
    
    if (error.type === 'StripeInvalidRequestError') {
      return res.status(400).json({
        success: false,
        error: 'Invalid Stripe session ID'
      })
    }
    
    return res.status(500).json({
      success: false,
      error: 'Failed to retrieve session data',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    })
  }
}