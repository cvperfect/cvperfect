// API endpoint to retrieve full CV session data for success page
import { handleCORSPreflight } from '../../lib/cors'

export default async function handler(req, res) {
  // Secure CORS handling
  const shouldContinue = handleCORSPreflight(req, res)
  if (!shouldContinue) {
    return // CORS preflight handled
  }

  if (req.method !== 'GET') {
    return res.status(405).json({ 
      success: false,
      error: 'Method not allowed. Only GET requests are accepted.' 
    })
  }

  try {
    // Set proper JSON content type first
    res.setHeader('Content-Type', 'application/json')
    
    const { session_id: rawSessionId, force_file } = req.query

    // Input sanitization
    const session_id = rawSessionId ? rawSessionId.trim() : null

    if (!session_id || session_id.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'Missing or empty session_id parameter'
      })
    }
    
    // ðŸŽ­ DEMO MODE: Handle demo session requests
    if (session_id === 'demo_session_12345') {
      console.log('ðŸŽ­ DEMO MODE: Returning sample CV data')
      
      const demoData = {
        sessionId: 'demo_session_12345',
        email: 'anna.kowalska@example.com',
        plan: 'premium',
        template: 'luxury',
        cvData: 'Anna Kowalska\nanna.kowalska@example.com | +48 123 456 789 | Warszawa, Polska\n\nDOÅšWIADCZENY FRONTEND DEVELOPER\n\nDoÅ›wiadczony Frontend Developer z 5-letnim doÅ›wiadczeniem w tworzeniu nowoczesnych aplikacji webowych. Specjalizuje siÄ™ w React, TypeScript i responsive design. Pasjonat UI/UX z silnymi umiejÄ™tnoÅ›ciami wspÃ³Å‚pracy w zespole.\n\nDOÅšWIADCZENIE ZAWODOWE\n\nSenior Frontend Developer | Tech Solutions Sp. z o.o. | Warszawa | 01/2022 - obecnie\nâ€¢ Liderowanie zespoÅ‚u 4 programistÃ³w w tworzeniu aplikacji e-commerce\nâ€¢ Implementacja responsive design i optymalizacja wydajnoÅ›ci\nâ€¢ ZwiÄ™kszenie conversion rate o 25% przez optymalizacjÄ™ UX\nâ€¢ Mentoring mÅ‚odszych developerÃ³w\n\nFrontend Developer | Digital Agency | KrakÃ³w | 06/2020 - 12/2021\nâ€¢ RozwÃ³j aplikacji SPA w React dla klientÃ³w z rÃ³Å¼nych branÅ¼\nâ€¢ WspÃ³Å‚praca z zespoÅ‚em UX/UI w tworzeniu przyjaznych interfejsÃ³w\nâ€¢ Implementacja responsive design zgodnie z zasadami accessibility\n\nUMIEJÄ˜TNOÅšCI\nâ€¢ Frontend: React, TypeScript, JavaScript (ES6+), HTML5, CSS3, SASS\nâ€¢ Frameworks: Next.js, Redux, Material-UI, Styled Components\nâ€¢ Tools: Git, Webpack, Jest, Figma, Adobe XD\nâ€¢ Metodyki: Responsive Design, Mobile First, REST API Integration\n\nWYKSZTAÅCENIE\nMagister Informatyki | Uniwersytet Warszawski | Warszawa | 2018-2020\nSpecjalizacja: InÅ¼ynieria Oprogramowania\n\nJÄ˜ZYKI\nâ€¢ Polski - ojczysty\nâ€¢ Angielski - zaawansowany (C1)\nâ€¢ Niemiecki - podstawowy (A2)',
        jobPosting: '',
        photo: null,
        timestamp: new Date().toISOString(),
        processed: false,
        createdAt: Date.now()
      }
      
      return res.status(200).json({
        success: true,
        source: 'demo_mode',
        cvData: demoData.cvData,
        email: demoData.email,
        plan: demoData.plan,
        jobPosting: demoData.jobPosting || '',
        photo: demoData.photo || null,
        processed: demoData.processed,
        session: {
          id: demoData.sessionId,
          customer_email: demoData.email,
          metadata: {
            plan: demoData.plan,
            template: demoData.template,
            cv: demoData.cvData,
            job: demoData.jobPosting,
            photo: demoData.photo,
            processed: demoData.processed,
            timestamp: demoData.timestamp,
            demo_mode: true
          }
        }
      })
    }
    
    // ENHANCED VALIDATION: Accept multiple session ID formats
    const isRegularSession = /^sess_[a-zA-Z0-9_]+$/.test(session_id)
    const isFallbackSession = /^fallback_[0-9]+_[a-zA-Z0-9]+$/.test(session_id)
    const isDemoSession = /^demo_session_[a-zA-Z0-9_]+$/.test(session_id)
    const isTestSession = /^test_[a-zA-Z0-9_]+$/.test(session_id)
    
    // More flexible validation
    const validSessionFormats = [
      isRegularSession,
      isFallbackSession, 
      isDemoSession,
      isTestSession
    ]
    
    if (typeof session_id !== 'string' || 
        !validSessionFormats.some(format => format) ||
        session_id.length > 100 || 
        session_id.length < 8) {
      return res.status(400).json({
        success: false,
        error: 'Invalid session_id format. Expected formats: sess_*, fallback_*, demo_session_*, or test_*',
        debug: `Received: ${session_id} (length: ${session_id.length})`
      })
    }
    
    const sessionType = isRegularSession ? 'regular' : 
                     isFallbackSession ? 'fallback' :
                     isDemoSession ? 'demo' : 
                     isTestSession ? 'test' : 'unknown'
    
    console.log('ðŸ” Session ID validation:', {
      sessionId: session_id,
      type: sessionType,
      length: session_id.length
    })

    const isForceFileMode = force_file === 'true'
    console.log('ðŸ” Retrieving session data for:', session_id, isForceFileMode ? '(FORCE FILE MODE)' : '')

    // Try to load from file system first
    const fs = require('fs').promises
    const path = require('path')
    
    try {
      const sessionsDir = path.join(process.cwd(), '.sessions')
      const sessionFile = path.join(sessionsDir, `${session_id}.json`)
      
      // Check if session file exists
      await fs.access(sessionFile)
      
      // Read session data
      const sessionData = JSON.parse(await fs.readFile(sessionFile, 'utf8'))
      
      console.log('âœ… Session data loaded:', {
        sessionId: sessionData.sessionId,
        email: sessionData.email,
        plan: sessionData.plan,
        cvLength: sessionData.cvData?.length || 0,
        hasJob: !!sessionData.jobPosting,
        hasPhoto: !!sessionData.photo,
        processed: sessionData.processed
      })

      // Return full session data (ENHANCED for FAZA 3)
      return res.status(200).json({
        success: true,
        source: 'filesystem',
        cvData: sessionData.cvData, // Direct access for fallback system
        email: sessionData.email,
        plan: sessionData.plan,
        jobPosting: sessionData.jobPosting || '',
        photo: sessionData.photo || null,
        processed: sessionData.processed,
        session: {
          id: sessionData.sessionId,
          customer_email: sessionData.email,
          metadata: {
            plan: sessionData.plan,
            template: sessionData.template,
            cv: sessionData.cvData, // FULL CV DATA - no truncation
            job: sessionData.jobPosting,
            photo: sessionData.photo, // Photo data preserved
            processed: sessionData.processed,
            timestamp: sessionData.timestamp
          }
        }
      })

    } catch (fileError) {
      console.log('ðŸ“ Session file not found, trying alternative methods...')
      
      // ENHANCED FALLBACK: For fallback session IDs, skip Stripe and return guidance
      if (isFallbackSession) {
        console.log('ðŸš‘ Fallback session detected - providing recovery guidance')
        return res.status(200).json({
          success: true,
          source: 'fallback_guidance',
          fallback: true,
          guidance: {
            message: 'Session data should be available in browser storage',
            recommendation: 'Check sessionStorage and localStorage for CV data',
            fallbackSessionId: session_id
          },
          session: {
            id: session_id,
            customer_email: null,
            payment_status: 'pending_recovery',
            metadata: {
              fallback: true,
              recovery_needed: true
            }
          }
        })
      }
      
      // If force_file mode is enabled, don't try Stripe
      if (isForceFileMode) {
        console.log('ðŸš« Force file mode - skipping Stripe fallback')
        return res.status(404).json({
          success: false,
          source: 'filesystem',
          error: 'Session file not found (force file mode)'
        })
      }
      
      console.log('ðŸ”„ Trying Stripe fallback...')
      
      // Fallback to Stripe session lookup
      const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY)
      
      try {
        const stripeSession = await stripe.checkout.sessions.retrieve(session_id)
        
        console.log('ðŸ“‹ Stripe session found:', {
          id: stripeSession.id,
          email: stripeSession.customer_email,
          status: stripeSession.payment_status,
          hasMetadata: !!stripeSession.metadata
        })

        // Return Stripe data (limited)
        return res.status(200).json({
          success: true,
          session: {
            id: stripeSession.id,
            customer_email: stripeSession.customer_email,
            payment_status: stripeSession.payment_status,
            metadata: stripeSession.metadata || {}
          }
        })

      } catch (stripeError) {
        console.error('âŒ Stripe session not found:', stripeError.message)
        
        return res.status(404).json({
          success: false,
          error: 'Session not found in both local storage and Stripe'
        })
      }
    }

  } catch (error) {
    console.error('âŒ Get session error:', error)
    
    // Ensure we always return JSON, even on errors
    res.setHeader('Content-Type', 'application/json')
    
    // Handle specific error types
    if (error.code === 'EACCES' || error.code === 'EPERM') {
      return res.status(500).json({
        success: false,
        error: 'File system permission error'
      })
    }
    
    if (error.type === 'StripeInvalidRequestError') {
      return res.status(400).json({
        success: false,
        error: 'Invalid Stripe session ID'
      })
    }
    
    return res.status(500).json({
      success: false,
      error: 'Failed to retrieve session data',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    })
  }
}