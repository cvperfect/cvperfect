// API endpoint to retrieve full CV session data for success page
import { handleCORSPreflight } from '../../lib/cors'

export default async function handler(req, res) {
  // Secure CORS handling
  const shouldContinue = handleCORSPreflight(req, res)
  if (!shouldContinue) {
    return // CORS preflight handled
  }

  if (req.method !== 'GET') {
    return res.status(405).json({ 
      success: false,
      error: 'Method not allowed. Only GET requests are accepted.' 
    })
  }

  try {
    // Set proper JSON content type first
    res.setHeader('Content-Type', 'application/json')
    
    const { session_id: rawSessionId, force_file } = req.query

    // Input sanitization
    const session_id = rawSessionId ? rawSessionId.trim() : null

    if (!session_id || session_id.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'Brak identyfikatora sesji / Missing session ID',
        errorPL: 'Nie podano identyfikatora sesji.',
        errorEN: 'Session ID parameter is missing or empty.'
      })
    }
    
    // Validate session_id format: sess_1234567890123_abcdefghi
    const sessionIdRegex = /^sess_\d{13}_[a-z0-9]{9}$/
    if (!sessionIdRegex.test(session_id) && session_id !== 'demo_session_12345') {
      return res.status(400).json({
        success: false,
        error: 'Nieprawid≈Çowy format sesji / Invalid session format',
        errorPL: 'Nieprawid≈Çowy format identyfikatora sesji.',
        errorEN: 'Invalid session ID format. Expected: sess_[timestamp]_[hash]',
        received: session_id
      })
    }
    
    // üé≠ DEMO MODE: Handle demo session requests
    if (session_id === 'demo_session_12345') {
      console.log('üé≠ DEMO MODE: Returning sample CV data')
      
      const demoData = {
        sessionId: 'demo_session_12345',
        email: 'anna.kowalska@example.com',
        plan: 'premium',
        template: 'luxury',
        cvData: 'Anna Kowalska\nanna.kowalska@example.com | +48 123 456 789 | Warszawa, Polska\n\nDO≈öWIADCZENY FRONTEND DEVELOPER\n\nDo≈õwiadczony Frontend Developer z 5-letnim do≈õwiadczeniem w tworzeniu nowoczesnych aplikacji webowych. Specjalizuje siƒô w React, TypeScript i responsive design. Pasjonat UI/UX z silnymi umiejƒôtno≈õciami wsp√≥≈Çpracy w zespole.\n\nDO≈öWIADCZENIE ZAWODOWE\n\nSenior Frontend Developer | Tech Solutions Sp. z o.o. | Warszawa | 01/2022 - obecnie\n‚Ä¢ Liderowanie zespo≈Çu 4 programist√≥w w tworzeniu aplikacji e-commerce\n‚Ä¢ Implementacja responsive design i optymalizacja wydajno≈õci\n‚Ä¢ Zwiƒôkszenie conversion rate o 25% przez optymalizacjƒô UX\n‚Ä¢ Mentoring m≈Çodszych developer√≥w\n\nFrontend Developer | Digital Agency | Krak√≥w | 06/2020 - 12/2021\n‚Ä¢ Rozw√≥j aplikacji SPA w React dla klient√≥w z r√≥≈ºnych bran≈º\n‚Ä¢ Wsp√≥≈Çpraca z zespo≈Çem UX/UI w tworzeniu przyjaznych interfejs√≥w\n‚Ä¢ Implementacja responsive design zgodnie z zasadami accessibility\n\nUMIEJƒòTNO≈öCI\n‚Ä¢ Frontend: React, TypeScript, JavaScript (ES6+), HTML5, CSS3, SASS\n‚Ä¢ Frameworks: Next.js, Redux, Material-UI, Styled Components\n‚Ä¢ Tools: Git, Webpack, Jest, Figma, Adobe XD\n‚Ä¢ Metodyki: Responsive Design, Mobile First, REST API Integration\n\nWYKSZTA≈ÅCENIE\nMagister Informatyki | Uniwersytet Warszawski | Warszawa | 2018-2020\nSpecjalizacja: In≈ºynieria Oprogramowania\n\nJƒòZYKI\n‚Ä¢ Polski - ojczysty\n‚Ä¢ Angielski - zaawansowany (C1)\n‚Ä¢ Niemiecki - podstawowy (A2)',
        jobPosting: '',
        photo: null,
        timestamp: new Date().toISOString(),
        processed: false,
        createdAt: Date.now()
      }
      
      return res.status(200).json({
        success: true,
        source: 'demo_mode',
        cvData: demoData.cvData,
        email: demoData.email,
        plan: demoData.plan,
        jobPosting: demoData.jobPosting || '',
        photo: demoData.photo || null,
        processed: demoData.processed,
        session: {
          id: demoData.sessionId,
          customer_email: demoData.email,
          metadata: {
            plan: demoData.plan,
            template: demoData.template,
            cv: demoData.cvData,
            job: demoData.jobPosting,
            photo: demoData.photo,
            processed: demoData.processed,
            timestamp: demoData.timestamp,
            demo_mode: true
          }
        }
      })
    }
    
    // üß† INTELLIGENT SESSION TYPE DETECTION
    const isRegularSession = /^sess_[a-zA-Z0-9_]+$/.test(session_id)
    const isFallbackSession = /^fallback_[0-9]+_[a-zA-Z0-9]+$/.test(session_id)
    const isDemoSession = /^demo_session_[a-zA-Z0-9_]+$/.test(session_id)
    const isTestSession = /^test_[a-zA-Z0-9_]+$/.test(session_id)
    const isStripeSession = /^cs_[a-zA-Z0-9_]+$/.test(session_id) // Stripe checkout sessions
    
    // Validate session format
    const validSessionFormats = [
      isRegularSession,
      isFallbackSession, 
      isDemoSession,
      isTestSession,
      isStripeSession
    ]
    
    if (typeof session_id !== 'string' || 
        !validSessionFormats.some(format => format) ||
        session_id.length > 100 || 
        session_id.length < 8) {
      return res.status(400).json({
        success: false,
        error: 'Invalid session_id format. Expected formats: sess_*, cs_*, fallback_*, demo_session_*, or test_*',
        debug: `Received: ${session_id} (length: ${session_id.length})`
      })
    }
    
    const sessionType = isRegularSession ? 'regular' : 
                       isFallbackSession ? 'fallback' :
                       isDemoSession ? 'demo' : 
                       isTestSession ? 'test' : 
                       isStripeSession ? 'stripe' : 'unknown'
    
    console.log('üîç Session ID validation:', {
      sessionId: session_id,
      type: sessionType,
      length: session_id.length
    })

    const isForceFileMode = force_file === 'true'
    console.log('üîç Retrieving session data for:', session_id, isForceFileMode ? '(FORCE FILE MODE)' : '')
    
    // üéØ ROUTE OPTIMIZATION: Skip Stripe for local sessions
    const isLocalSession = isRegularSession || isFallbackSession || isDemoSession || isTestSession
    if (isLocalSession) {
      console.log('üìÅ Local session detected - skipping Stripe, going directly to filesystem')
    }

    // Try to load from file system first
    const fs = require('fs').promises
    const path = require('path')
    
    try {
      const sessionsDir = path.join(process.cwd(), '.sessions')
      const sessionFile = path.join(sessionsDir, `${session_id}.json`)
      
      // Check if session file exists
      await fs.access(sessionFile)
      
      // Read session data
      const sessionData = JSON.parse(await fs.readFile(sessionFile, 'utf8'))
      
      console.log('‚úÖ Session data loaded:', {
        sessionId: sessionData.sessionId,
        email: sessionData.email,
        plan: sessionData.plan,
        cvLength: sessionData.cvData?.length || 0,
        hasJob: !!sessionData.jobPosting,
        hasPhoto: !!sessionData.photo,
        processed: sessionData.processed
      })

      // Return full session data (ENHANCED for FAZA 3)
      return res.status(200).json({
        success: true,
        source: 'filesystem',
        cvData: sessionData.cvData, // Direct access for fallback system
        email: sessionData.email,
        plan: sessionData.plan,
        jobPosting: sessionData.jobPosting || '',
        photo: sessionData.photo || null,
        processed: sessionData.processed,
        session: {
          id: sessionData.sessionId,
          customer_email: sessionData.email,
          metadata: {
            plan: sessionData.plan,
            template: sessionData.template,
            cv: sessionData.cvData, // FULL CV DATA - no truncation
            job: sessionData.jobPosting,
            photo: sessionData.photo, // Photo data preserved
            processed: sessionData.processed,
            timestamp: sessionData.timestamp
          }
        }
      })

    } catch (fileError) {
      console.log('üìù Session file not found, trying alternative methods...')
      
      // ENHANCED FALLBACK: For fallback session IDs, provide demo data immediately
      if (isFallbackSession) {
        console.log('üöë Fallback session detected - providing demo data immediately')
        
        const demoCV = `Jan Kowalski
Software Developer
jan.kowalski@example.com | +48 123 456 789 | Warszawa

DO≈öWIADCZENIE ZAWODOWE:
‚Ä¢ Senior Frontend Developer - TechCorp (2022-2024)
  - Rozwijanie aplikacji React.js i Next.js
  - Optymalizacja wydajno≈õci i SEO
  - Wsp√≥≈Çpraca z zespo≈Çem 8 deweloper√≥w
  
‚Ä¢ Frontend Developer - WebStudio (2020-2022)  
  - Tworzenie responsywnych stron internetowych
  - Implementacja nowoczesnych rozwiƒÖza≈Ñ CSS
  - Praca z REST API i GraphQL

UMIEJƒòTNO≈öCI:
‚Ä¢ JavaScript, TypeScript, React.js, Next.js
‚Ä¢ CSS3, SASS, Styled Components
‚Ä¢ Node.js, Express.js, MongoDB
‚Ä¢ Git, Docker, AWS
‚Ä¢ Responsive Web Design, PWA

WYKSZTA≈ÅCENIE:
‚Ä¢ Informatyka, Politechnica Warszawska (2016-2020)
‚Ä¢ In≈ºynier, ≈õrednia 4.5/5.0

JƒòZYKI:
‚Ä¢ Polski - ojczysty
‚Ä¢ Angielski - zaawansowany (C1)
‚Ä¢ Niemiecki - podstawowy (A2)`

        return res.status(200).json({
          success: true,
          source: 'demo-fallback',
          cvData: demoCV,
          email: 'demo@cvperfect.pl',
          plan: 'premium',
          jobPosting: '',
          photo: null,
          processed: true,
          isDemoMode: true,
          session: {
            id: session_id,
            customer_email: 'demo@cvperfect.pl',
            payment_status: 'complete',
            metadata: {
              plan: 'premium',
              cv: demoCV,
              processed: true,
              isDemoMode: true,
              timestamp: Date.now()
            }
          }
        })
      }
      
      // üéØ OPTIMIZED ROUTING: Only try Stripe for actual Stripe sessions
      if (isLocalSession && !isForceFileMode) {
        console.log('‚ùå Local session file not found - returning 404 (skipping Stripe)')
        return res.status(404).json({
          success: false,
          source: 'filesystem',
          error: 'Local session file not found',
          sessionType: sessionType
        })
      }
      
      // If force_file mode is enabled, don't try Stripe
      if (isForceFileMode) {
        console.log('üö´ Force file mode - skipping Stripe fallback')
        return res.status(404).json({
          success: false,
          source: 'filesystem',
          error: 'Session file not found (force file mode)'
        })
      }
      
      // Only try Stripe for actual Stripe sessions (cs_*)
      if (isStripeSession) {
        console.log('üîÑ Stripe session detected - trying Stripe API...')
        
        // Fallback to Stripe session lookup
        const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY)
        
        try {
          // RETRY LOGIC WITH EXPONENTIAL BACKOFF for session propagation delays
          let stripeSession = null
          let lastError = null
          const maxRetries = 5
          
          for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
              stripeSession = await stripe.checkout.sessions.retrieve(session_id)
              console.log(`‚úÖ Stripe session retrieved on attempt ${attempt}`)
              break
            } catch (error) {
              lastError = error
              
              if (error.code === 'resource_missing' && attempt < maxRetries) {
                // Exponential backoff: 300ms, 600ms, 1200ms, 2400ms
                const delay = 300 * Math.pow(2, attempt - 1)
                console.log(`‚è≥ Stripe retry attempt ${attempt} failed, retrying in ${delay}ms...`)
                await new Promise(resolve => setTimeout(resolve, delay))
                continue
              } else {
                // Re-throw if not resource_missing or last attempt
                throw error
              }
            }
          }
          
          if (!stripeSession) {
            throw lastError || new Error('Failed to retrieve Stripe session after retries')
          }
          
          console.log('üìã Stripe session found:', {
            id: stripeSession.id,
            email: stripeSession.customer_email,
            status: stripeSession.payment_status,
            hasMetadata: !!stripeSession.metadata
          })

          // Return Stripe data (limited)
          return res.status(200).json({
            success: true,
            source: 'stripe',
            session: {
              id: stripeSession.id,
              customer_email: stripeSession.customer_email,
              payment_status: stripeSession.payment_status,
              metadata: stripeSession.metadata || {}
            }
          })

        } catch (stripeError) {
          console.error('‚ùå Stripe session not found:', stripeError.message)
          
          return res.status(404).json({
            success: false,
            source: 'stripe',
            error: 'Stripe session not found'
          })
        }
      } else {
        console.log('‚ùå Session not found and no valid fallback available')
        return res.status(404).json({
          success: false,
          error: 'Session not found',
          sessionType: sessionType
        })
      }
    }

  } catch (error) {
    console.error('‚ùå Get session error:', error)
    
    // Ensure we always return JSON, even on errors
    res.setHeader('Content-Type', 'application/json')
    
    // Handle specific error types
    if (error.code === 'EACCES' || error.code === 'EPERM') {
      return res.status(500).json({
        success: false,
        error: 'File system permission error'
      })
    }
    
    if (error.type === 'StripeInvalidRequestError') {
      return res.status(400).json({
        success: false,
        error: 'Invalid Stripe session ID'
      })
    }
    
    return res.status(500).json({
      success: false,
      error: 'Failed to retrieve session data',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    })
  }
}